options{  JDK_VERSION = "1.5";  STATIC = false;}PARSER_BEGIN(LuaParser)package parser;import util.*;import core.*;import java.util.*;public class LuaParser{	public static Trecho parse(java.io.File file) {		LuaParser parser;		Trecho trecho = null;		System.out.println("Lua PLP Parser Version 0.0.1: Reading from file " + file.getName() + "...");		try {			parser = new LuaParser(new java.io.FileInputStream(file));		} catch (java.io.FileNotFoundException e) {			System.out.println("Lua PLP Parser Version 0.0.1: File " + file.getName() + " not found.");			return null;		}		try {			trecho = parser.Trecho();			System.out.println("Lua PLP Parser Version 0.0.1: Lua program parsed successfully.");		} catch (ParseException e) {			System.out.println("Lua PLP Parser Version 0.0.1: Encountered errors during parse.");			System.out.println(e.getMessage());		}		return trecho;	}  private static Exp.VarExp assertvarexp(Exp.ExpPrimaria pe) throws ParseException {  	if (!pe.isvarexp()) 		throw new ParseException("expected variable");	return (Exp.VarExp) pe;   }  private static Exp.ChamadaFunc assertfunccall(Exp.ExpPrimaria pe) throws ParseException {  	if (!pe.isfunccall()) 		throw new ParseException("expected function call");	return (Exp.ChamadaFunc) pe;   }} PARSER_END(LuaParser)/* WHITE SPACE */SKIP :{  " " | "\t" | "\n" | "\r" | "\f"}/* COMMENTS and LONG STRINGS */MORE :{  "--[[": IN_LC0| "--[=[": IN_LC1| "--[==[": IN_LC2| "--[===[": IN_LC3| < "--[====" ("=")* "[" > : IN_LCN| "[[" : IN_LS0| "[=[" : IN_LS1| "[==[" : IN_LS2| "[===[" : IN_LS3| < "[====" ("=")* "[" > : IN_LSN| "--"   : IN_COMMENT}<IN_COMMENT> SPECIAL_TOKEN :{  <COMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT}<IN_LC0> SPECIAL_TOKEN : { <LONGCOMMENT0: "]]" > : DEFAULT }<IN_LC1> SPECIAL_TOKEN : { <LONGCOMMENT1: "]=]" > : DEFAULT }<IN_LC2> SPECIAL_TOKEN : { <LONGCOMMENT2: "]==]" > : DEFAULT }<IN_LC3> SPECIAL_TOKEN : { <LONGCOMMENT3: "]===]" > : DEFAULT }<IN_LCN> SPECIAL_TOKEN : { <LONGCOMMENTN: "]====" ("=")* "]" > : DEFAULT }<IN_LS0> TOKEN : { <LONGSTRING0: "]]" > : DEFAULT }<IN_LS1> TOKEN : { <LONGSTRING1: "]=]" > : DEFAULT }<IN_LS2> TOKEN : { <LONGSTRING2: "]==]" > : DEFAULT }<IN_LS3> TOKEN : { <LONGSTRING3: "]===]" > : DEFAULT }<IN_LSN> TOKEN : { <LONGSTRINGN: "]====" ("=")* "]" > : DEFAULT }<IN_LC0,IN_LC1,IN_LC2,IN_LC3,IN_LCN,IN_LS0,IN_LS1,IN_LS2,IN_LS3,IN_LSN> MORE :{  < ~[] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  <AND: "and">| <BREAK: "break">| <DO: "do">| <ELSE: "else">| <ELSEIF: "elseif">| <END: "end">| <FALSE: "false">| <FOR: "for">| <FUNCTION: "function">| <GOTO: "goto">| <IF: "if">| <IN: "in">| <LOCAL: "local">| <NIL: "nil">| <NOT: "not">| <OR: "or">| <RETURN: "return">| <REPEAT: "repeat">| <THEN: "then">| <TRUE: "true">| <UNTIL: "until">| <WHILE: "while">}/* LITERALS */TOKEN :{  < NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >| < NUMBER: <HEX> | <FLOAT> >| < #FLOAT: <FNUM> (<EXP>)? >| < #FNUM: (<DIGIT>)+ "." (<DIGIT>)* | "." (<DIGIT>)+ | (<DIGIT>)+ >| < #DIGIT: ["0"-"9"] >| < #EXP: ["e","E"] (["+","-"])? (<DIGIT>)+ >| < #HEX: "0" ["x","X"] <HEXNUM> (<HEXEXP>)? >| < #HEXNUM: (<HEXDIGIT>)+ "." (<HEXDIGIT>)* | "." (<HEXDIGIT>)+ | (<HEXDIGIT>)+ >| < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >| < #HEXEXP: ["e","E","p","P"] (["+","-"])? (<DIGIT>)+ >| < STRING: "\"" (<QUOTED> | ~["\\","\""])* "\"" >| < CHARSTRING: "'" (<QUOTED> | ~["\\","'"])* "'" >| < #QUOTED: <DECIMAL> | <UNICODE> | <CHAR> >| < #DECIMAL:   "\\" ["0"-"9"] (["0"-"9"])? (["0"-"9"])? >| < DBCOLON: "::" >| < #UNICODE: "\\" "u" <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> >| < #CHAR: "\\" (~[]) >| < #LF: ("\n" | "\r" | "\r\n") >}/** Root production. */Trecho Trecho():{	Bloco b;	Trecho t;}{	("#"{token_source.SwitchTo(IN_COMMENT);})? b=Bloco() <EOF> {t=new Trecho(b); return t;}}Bloco Bloco():{	Bloco b = new Bloco();	Comando c;}{	(c=Comando() {b.add(c);})* (c=ReturnComando() {b.add(c);})? {return b;} }Comando Comando():{  	Bloco b;  	Exp e,e2,e3=null;	Comando c;	Token n;	FuncNome fn;	FuncCorpo fb;	List<Nome> nl;	List<Exp> el=null;}{	";" {return null;}	|<DO> b=Bloco() <END> { c=Comando.bloco(b); return c;}	|<WHILE> e=Exp() <DO> b=Bloco() <END> {c=Comando.whiledo(e,b); return c;}	|c=ExprComando() {return c;}	|c=IfThenElse()  {return c;}	|LOOKAHEAD(3) <FOR> n=<NAME> "=" e=Exp() "," e2=Exp() ( "," e3=Exp() )? <DO> b=Bloco() <END>{c=Comando.fornumerico(n.image,e,e2,e3,b); return c;}	|<FUNCTION> fn=FuncNome() fb=FuncCorpo() { c=Comando.deffuncao(fn,fb); return c;}	|<FOR> nl=ListaNome() <IN> el=ExpList() <DO> b=Bloco() <END> { c=Comando.forgenerico(nl,el,b); return c; }	|<LOCAL> nl=ListaNome() ( "=" el=ExpList() )?  { c=Comando.atribuicaolocal(nl,el); return c; }}Comando IfThenElse():{	Bloco b,b2,b3=null;	Exp e,e2;	List<Exp> el=null;	List<Bloco> bl=null; }{	<IF> e=Exp() 		<THEN> b=Bloco() 		(<ELSEIF> e2=Exp() <THEN> b2=Bloco() { 			if (el==null) el=new ArrayList<Exp>(); 			if (bl==null) bl=new ArrayList<Bloco>(); 			el.add(e2);			bl.add(b2);		} )* 		(<ELSE> b3=Bloco())? <END> 			{ return Comando.ifthenelse(e,b,el,bl,b3); }}Comando ReturnComando():{	List<Exp> el=null;	Comando c;}{	<RETURN> (el=ExpList())? ( ";" )? {c=Comando.returncomando(el); return c;}}Comando ExprComando():{	Exp.ExpPrimaria p;	Comando c=null;}{	p=ExpPrimaria()	(c=Atribui(assertvarexp(p)))?	{if(c==null){c=Comando.chamadafunc(assertfunccall(p));}return c;}}Comando Atribui(Exp.VarExp v0):{	List<Exp.VarExp> vl = new ArrayList<Exp.VarExp>();	vl.add(v0);	Exp.VarExp ve;	List<Exp> el;	Comando c;}{	("," ve=VarExp() {vl.add(ve);})* "=" el=ExpList() {c=Comando.atribuicao(vl,el); return c;}}Exp Exp():{	Exp e,s;	int op;}{	(e=SimpleExp() | op=Unop() s=Exp() {e=Exp.expunaria(op,s);}) 	(LOOKAHEAD(2) op=Binop() s=Exp() {e=Exp.expbinaria(e,op,s);})* {return e;}}Exp SimpleExp():{	Token n;	Exp e;	ConstrutorTabela c;}{		<NIL>					{ e=new LuaNil(); return e;} 			|	<TRUE>					{ e=new LuaBoolean(true); return e;}	|	<FALSE>					{ e=new LuaBoolean(false); return e;}	|	n=<NUMBER>				{ e=new LuaNumber(Integer.parseInt(n.toString())); return e; }	|	e=Str()					{ return e;}	|	c=ConstrutorTabela()	{ e=Exp.construtortabela(c); return e; }	|	e=ExpPrimaria()			{ return e; } }Exp.VarExp VarExp():{	Exp.ExpPrimaria p;}{	p=ExpPrimaria() {return assertvarexp(p);}	}Exp.ExpPrimaria ExpPrimaria(): {		Exp.ExpPrimaria p;}{	p=ExpPrefixa() (LOOKAHEAD(2) p=OpPosFixo(p))* {return p;}}Exp.ExpPrimaria OpPosFixo(Exp.ExpPrimaria lhs):{	Token n;	Exp e;	FuncArgs a;	Exp.ExpPrimaria p;}{	a=FuncArgs() {p=Exp.functionop(lhs, a); return p;}	|"[" e=Exp() "]" {p=Exp.indexop(lhs, e); return p; }}Exp.ExpPrimaria ExpPrefixa():{	Token n;	Exp e;	Exp.ExpPrimaria p;}{	n=<NAME>		 { p=Exp.nomeprefix(n.image); return p;}	|"(" e=Exp() ")" { p=Exp.parensprefix(e); return p;}}List<Exp> ExpList():{	List<Exp> l = new ArrayList<Exp>();	Exp e;}{	e=Exp() {l.add(e);} ("," e=Exp() {l.add(e);})* {return l;}}FuncArgs FuncArgs():{	List<Exp> el=null;	LuaString s;	FuncArgs a;}{	"(" (el=ExpList())? ")"	{ a=FuncArgs.explist(el); return a; }	|	s=Str()				{ a=FuncArgs.string(s); return a; }}FuncNome FuncNome():{	Token n;	FuncNome f;}{	n=<NAME> {f=new FuncNome(n.image);} 		( "." n=<NAME> {f.addponto(n.image);} )* 		( ":" n=<NAME> {f.metodo=n.image;} )? 			{return f;}}FuncCorpo FuncCorpo():{	ParList pl=null;	Bloco b;	FuncCorpo f;}{	"(" ( pl=ParList() )? ")" b=Bloco() <END> {f=new FuncCorpo(pl,b); return f;}}ParList ParList():{	List<Nome> l=null;	boolean v=false;	ParList p;}{	l=ListaNome() ("," "..." {v=true;})? {p=new ParList(l,v); return p;} 	| "..." { p=new ParList(null,true); return p;}}List<Nome> ListaNome():{	List<Nome> l = new ArrayList<Nome>();	Token nome;}{	nome=<NAME> {l.add(new Nome(nome.image));} (LOOKAHEAD(2) "," nome=<NAME> {l.add(new Nome(nome.image));})* {return l;}}ConstrutorTabela ConstrutorTabela():{	ConstrutorTabela c = new ConstrutorTabela();	List<CampoTabela> l = null;}{	"{" ( l=ListaCampos() {c.campos=l;} )? "}" {return c; }}List<CampoTabela> ListaCampos():{	List<CampoTabela> l = new ArrayList<CampoTabela>();	CampoTabela f;}{	f=Campo() {l.add(f);} (LOOKAHEAD(2) CampoSep() f=Campo() {l.add(f);})* (CampoSep())? { return l; }}CampoTabela Campo():{	Token nome;	Exp exp,rhs;	CampoTabela f;}{	"[" exp=Exp() "]" "=" rhs=Exp()         	 	{ f=CampoTabela.campoChaveado(exp,rhs); return f; }	|	LOOKAHEAD(2) nome=<NAME> "=" rhs=Exp()  	{ f=CampoTabela.campoNomeado(nome.image,rhs); return f; }	|	rhs=Exp()                               	{ f=CampoTabela.listCampos(rhs);  return f; }}void CampoSep():{}{	"," | ";"}int Binop():{}	{		"+"   { return LuaOps.OP_ADD; }	|	"-"   { return LuaOps.OP_SUB; } 	|	"*"   { return LuaOps.OP_MUL; } 	|	"/"   { return LuaOps.OP_DIV; } 	|	"^"   { return LuaOps.OP_POW; } 	|	"%"   { return LuaOps.OP_MOD; } 	|	".."  { return LuaOps.OP_CONCAT; } 	|	"<"   { return LuaOps.OP_LT;  } 	|	"<="  { return LuaOps.OP_LE;  } 	|	">"   { return LuaOps.OP_GT;  } 	|	">="  { return LuaOps.OP_GE;  }	|	"=="  { return LuaOps.OP_EQ;  } 	|	"~="  { return LuaOps.OP_NEQ; } 	|	<AND> { return LuaOps.OP_AND; } 	|	<OR>  { return LuaOps.OP_OR;  }}int Unop():{}{		"-"   { return LuaOps.OP_UNM; }	|	<NOT> { return LuaOps.OP_NOT; } 	|	"#"   { return LuaOps.OP_LEN; }}LuaString Str():{  Token n;}{  n = <STRING>  { String tokenStr = n.toString();    tokenStr = tokenStr.substring(1, tokenStr.length() - 1);    return new LuaString(tokenStr);  }}