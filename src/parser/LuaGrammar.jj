options{  JDK_VERSION = "1.5";  STATIC = false;}PARSER_BEGIN(LuaGrammar)package parser;import util.*;import core.*;public class LuaGrammar{  public void process() throws Exception  {    while (true)    {      Token t = getNextToken();      String nomeToken = tokenImage [t.kind];      System.out.println(nomeToken);      if (t.kind == ponto_virg) break;    }  }}PARSER_END(LuaGrammar)/* WHITE SPACE */SKIP :{  " " | "\t" | "\n" | "\r" | "\f"}/* COMMENTS and LONG STRINGS */MORE :{  "--[[": IN_LC0| "--[=[": IN_LC1| "--[==[": IN_LC2| "--[===[": IN_LC3| < "--[====" ("=")* "[" > : IN_LCN| "[[" : IN_LS0| "[=[" : IN_LS1| "[==[" : IN_LS2| "[===[" : IN_LS3| < "[====" ("=")* "[" > : IN_LSN| "--"   : IN_COMMENT}<IN_COMMENT> SPECIAL_TOKEN :{  <COMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT}<IN_LC0> SPECIAL_TOKEN : { <LONGCOMMENT0: "]]" > : DEFAULT }<IN_LC1> SPECIAL_TOKEN : { <LONGCOMMENT1: "]=]" > : DEFAULT }<IN_LC2> SPECIAL_TOKEN : { <LONGCOMMENT2: "]==]" > : DEFAULT }<IN_LC3> SPECIAL_TOKEN : { <LONGCOMMENT3: "]===]" > : DEFAULT }<IN_LCN> SPECIAL_TOKEN : { <LONGCOMMENTN: "]====" ("=")* "]" > : DEFAULT }<IN_LS0> TOKEN : { <LONGSTRING0: "]]" > : DEFAULT }<IN_LS1> TOKEN : { <LONGSTRING1: "]=]" > : DEFAULT }<IN_LS2> TOKEN : { <LONGSTRING2: "]==]" > : DEFAULT }<IN_LS3> TOKEN : { <LONGSTRING3: "]===]" > : DEFAULT }<IN_LSN> TOKEN : { <LONGSTRINGN: "]====" ("=")* "]" > : DEFAULT }<IN_LC0,IN_LC1,IN_LC2,IN_LC3,IN_LCN,IN_LS0,IN_LS1,IN_LS2,IN_LS3,IN_LSN> MORE :{  < ~[] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  <AND: "and">| <BREAK: "break">| <DO: "do">| <ELSE: "else">| <ELSEIF: "elseif">| <END: "end">| <FALSE: "false">| <FOR: "for">| <FUNCTION: "function">| <GOTO: "goto">| <IF: "if">| <IN: "in">| <LOCAL: "local">| <NIL: "nil">| <NOT: "not">| <OR: "or">| <RETURN: "return">| <REPEAT: "repeat">| <THEN: "then">| <TRUE: "true">| <UNTIL: "until">| <WHILE: "while">}/* LITERALS */TOKEN :{  < NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >| < NUMBER: <HEX> | <FLOAT> >| < #FLOAT: <FNUM> (<EXP>)? >| < #FNUM: (<DIGIT>)+ "." (<DIGIT>)* | "." (<DIGIT>)+ | (<DIGIT>)+ >| < #DIGIT: ["0"-"9"] >| < #EXP: ["e","E"] (["+","-"])? (<DIGIT>)+ >| < #HEX: "0" ["x","X"] <HEXNUM> (<HEXEXP>)? >| < #HEXNUM: (<HEXDIGIT>)+ "." (<HEXDIGIT>)* | "." (<HEXDIGIT>)+ | (<HEXDIGIT>)+ >| < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >| < #HEXEXP: ["e","E","p","P"] (["+","-"])? (<DIGIT>)+ >| < STRING: "\"" (<QUOTED> | ~["\\","\""])* "\"" >| < CHARSTRING: "'" (<QUOTED> | ~["\\","'"])* "'" >| < #QUOTED: <DECIMAL> | <UNICODE> | <CHAR> >| < #DECIMAL:   "\\" ["0"-"9"] (["0"-"9"])? (["0"-"9"])? >| < DBCOLON: "::" >| < #UNICODE: "\\" "u" <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> >| < #CHAR: "\\" (~[]) >| < #LF: ("\n" | "\r" | "\r\n") >}/** Root production. */Trecho Trecho():{	Bloco b;	Trecho t;}{	("#"{token_source.SwitchTo(IN_COMMENT);})? b=Bloco() <EOF> {t=new Trecho(b); return t;}}Bloco Bloco():{	Bloco b = new Bloco();	Comando c;}{	(c=Comando() {b.add(c);})* {return b;} }Comando Comando():{	Comando c;}{	";" {return null;}	|c=ExprComando() {return c;}}Comando ExprComando():{	Exp.ExpPrimaria p;	Comando c=null;}{	p=ExpPrimaria()	(c=Assign(assertvarexp(p)))?	{return c;}}Comando Assign(Exp.VarExp v0):{	List<Exp.VarExp> vl = new ArrayList<Exp.VarExp>();	vl.add(v0);	Exp.VarExp ve;	List<Exp> el;	Comando c;}{	("," ve=VarExp() {vl.add(ve);})* "=" el=ExpList() {c=Comando.assignment(vl,el); return c;}}Exp.VarExp VarExp():{	Exp.ExpPrimaria p;}{	p=ExpPrimaria() {return assertvarexp(p);}	}Exp.ExpPrimaria ExpPrimaria(): {		Exp.ExpPrimaria p;}{	p=ExpPrefixa() {return p;}}Exp.ExpPrimaria ExpPrefixa():{	Token n;	Exp e;	Exp.ExpPrimaria p;}{	n=<NAME>		 { p=Exp.nomeprefix(n.image); return p;}	|"(" e=Exp() ")" { p=Exp.parensprefix(e); return p;}}List<Exp> ExpList():{	List<Exp> l = new ArrayList<Exp>();	Exp e;}{	e=Exp() {l.add(e);} ("," e=Exp() {l.add(e);})* {return l;}}Exp Exp():{	Exp e,s;	int op;}{	(e=SimpleExp() | op=Unop() s=Exp() {e=Exp.expunaria(op,s);}) 	(LOOKAHEAD(2) op=Binop() s=Exp() {e=Exp.expbinaria(e,op,s);})* {return e;}}Exp SimpleExp():{	Token n;	LuaString s;	Exp e;}{		<NIL>					{ e=Exp.constant(LuaValue.NIL); return e;} 			|	<TRUE>					{ e=Exp.constant(LuaValue.TRUE); return e;}	|	<FALSE>					{ e=Exp.constant(LuaValue.FALSE); return e;}	|	n=<NUMBER>				{ e=Exp.numberconstant(n.image); return e; }	|	s=Str()					{ e=Exp.constant(s); return e;}	|	e=ExpPrimaria()			{ return e; } }int Binop():{}	{		"+"   { return Lua.OP_ADD; }	|	"-"   { return Lua.OP_SUB; } 	|	"*"   { return Lua.OP_MUL; } 	|	"/"   { return Lua.OP_DIV; } 	|	"^"   { return Lua.OP_POW; } 	|	"%"   { return Lua.OP_MOD; } 	|	".."  { return Lua.OP_CONCAT; } 	|	"<"   { return Lua.OP_LT;  } 	|	"<="  { return Lua.OP_LE;  } 	|	">"   { return Lua.OP_GT;  } 	|	">="  { return Lua.OP_GE;  }	|	"=="  { return Lua.OP_EQ;  } 	|	"~="  { return Lua.OP_NEQ; } 	|	<AND> { return Lua.OP_AND; } 	|	<OR>  { return Lua.OP_OR;  }}int Unop():{}{		"-"   { return Lua.OP_UNM; }	|	<NOT> { return Lua.OP_NOT; } 	|	"#"   { return Lua.OP_LEN; }}LuaString Str():{}{	<STRING>		{ return Str.quoteString(token.image); } |	<CHARSTRING>	{ return Str.charString(token.image); }}