options{  JDK_VERSION = "1.5";  STATIC = false;}PARSER_BEGIN(LuaParser)package parser;import util.*;import core.*;import java.util.*;public class LuaParser{  public static void main(String args [])  {    LuaParser parser;    if (args.length == 0)    {      System.out.println("Lua PLP Parser Version 0.0.1: Reading from standard input . . .");      parser = new LuaParser(System.in);    }    else if (args.length == 1)    {      System.out.println("Lua PLP Parser Version 0.0.1: Reading from file " + args [0] + " . . .");      try      {        parser = new LuaParser(new java.io.FileInputStream(args [0]));      }      catch (java.io.FileNotFoundException e)      {        System.out.println("Java Parser Version 1.0.2: File " + args [0] + " not found.");        return;      }    }    else    {      System.out.println("Lua PLP Parser Version 0.0.1: Usage is one of:");      System.out.println("         java LuaGrammar < inputfile");      System.out.println("OR");      System.out.println("         java LuaGrammar inputfile");      return;    }    try    {      Trecho trecho;      trecho = parser.Trecho();      System.out.println("Lua PLP Parser Version 0.0.1: Lua program parsed successfully.");      //trecho.accept(trecho);          }    catch (ParseException e)    {      System.out.println("Lua PLP Parser Version 0.0.1: Encountered errors during parse.");       System.out.println(e.getMessage());    }  }  private static Exp.VarExp assertvarexp(Exp.ExpPrimaria pe) throws ParseException {  	if (!pe.isvarexp()) 		throw new ParseException("expected variable");	return (Exp.VarExp) pe;   }  private static Exp.ChamadaFunc assertfunccall(Exp.ExpPrimaria pe) throws ParseException {  	if (!pe.isfunccall()) 		throw new ParseException("expected function call");	return (Exp.ChamadaFunc) pe;   }} PARSER_END(LuaParser)/* WHITE SPACE */SKIP :{  " " | "\t" | "\n" | "\r" | "\f"}/* COMMENTS and LONG STRINGS */MORE :{  "--[[": IN_LC0| "--[=[": IN_LC1| "--[==[": IN_LC2| "--[===[": IN_LC3| < "--[====" ("=")* "[" > : IN_LCN| "[[" : IN_LS0| "[=[" : IN_LS1| "[==[" : IN_LS2| "[===[" : IN_LS3| < "[====" ("=")* "[" > : IN_LSN| "--"   : IN_COMMENT}<IN_COMMENT> SPECIAL_TOKEN :{  <COMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT}<IN_LC0> SPECIAL_TOKEN : { <LONGCOMMENT0: "]]" > : DEFAULT }<IN_LC1> SPECIAL_TOKEN : { <LONGCOMMENT1: "]=]" > : DEFAULT }<IN_LC2> SPECIAL_TOKEN : { <LONGCOMMENT2: "]==]" > : DEFAULT }<IN_LC3> SPECIAL_TOKEN : { <LONGCOMMENT3: "]===]" > : DEFAULT }<IN_LCN> SPECIAL_TOKEN : { <LONGCOMMENTN: "]====" ("=")* "]" > : DEFAULT }<IN_LS0> TOKEN : { <LONGSTRING0: "]]" > : DEFAULT }<IN_LS1> TOKEN : { <LONGSTRING1: "]=]" > : DEFAULT }<IN_LS2> TOKEN : { <LONGSTRING2: "]==]" > : DEFAULT }<IN_LS3> TOKEN : { <LONGSTRING3: "]===]" > : DEFAULT }<IN_LSN> TOKEN : { <LONGSTRINGN: "]====" ("=")* "]" > : DEFAULT }<IN_LC0,IN_LC1,IN_LC2,IN_LC3,IN_LCN,IN_LS0,IN_LS1,IN_LS2,IN_LS3,IN_LSN> MORE :{  < ~[] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  <AND: "and">| <BREAK: "break">| <DO: "do">| <ELSE: "else">| <ELSEIF: "elseif">| <END: "end">| <FALSE: "false">| <FOR: "for">| <FUNCTION: "function">| <GOTO: "goto">| <IF: "if">| <IN: "in">| <LOCAL: "local">| <NIL: "nil">| <NOT: "not">| <OR: "or">| <RETURN: "return">| <REPEAT: "repeat">| <THEN: "then">| <TRUE: "true">| <UNTIL: "until">| <WHILE: "while">}/* LITERALS */TOKEN :{  < NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >| < NUMBER: <HEX> | <FLOAT> >| < #FLOAT: <FNUM> (<EXP>)? >| < #FNUM: (<DIGIT>)+ "." (<DIGIT>)* | "." (<DIGIT>)+ | (<DIGIT>)+ >| < #DIGIT: ["0"-"9"] >| < #EXP: ["e","E"] (["+","-"])? (<DIGIT>)+ >| < #HEX: "0" ["x","X"] <HEXNUM> (<HEXEXP>)? >| < #HEXNUM: (<HEXDIGIT>)+ "." (<HEXDIGIT>)* | "." (<HEXDIGIT>)+ | (<HEXDIGIT>)+ >| < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >| < #HEXEXP: ["e","E","p","P"] (["+","-"])? (<DIGIT>)+ >| < STRING: "\"" (<QUOTED> | ~["\\","\""])* "\"" >| < CHARSTRING: "'" (<QUOTED> | ~["\\","'"])* "'" >| < #QUOTED: <DECIMAL> | <UNICODE> | <CHAR> >| < #DECIMAL:   "\\" ["0"-"9"] (["0"-"9"])? (["0"-"9"])? >| < DBCOLON: "::" >| < #UNICODE: "\\" "u" <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> <HEXDIGIT> >| < #CHAR: "\\" (~[]) >| < #LF: ("\n" | "\r" | "\r\n") >}/** Root production. */Trecho Trecho():{	Bloco b;	Trecho t;}{	("#"{token_source.SwitchTo(IN_COMMENT);})? b=Bloco() <EOF> {t=new Trecho(b); return t;}}Bloco Bloco():{	Bloco b = new Bloco();	Comando c;}{	(c=Comando() {b.add(c);})* {return b;} }Comando Comando():{	Comando c;}{	";" {return null;}	|c=ExprComando() {return c;}}Comando ExprComando():{	Exp.ExpPrimaria p;	Comando c=null;}{	p=ExpPrimaria()	(c=Assign(assertvarexp(p)))?	{if(c==null){c=Comando.chamadafunc(assertfunccall(p));}return c;}}Comando Assign(Exp.VarExp v0):{	List<Exp.VarExp> vl = new ArrayList<Exp.VarExp>();	vl.add(v0);	Exp.VarExp ve;	List<Exp> el;	Comando c;}{	("," ve=VarExp() {vl.add(ve);})* "=" el=ExpList() {c=Comando.assignment(vl,el); return c;}}Exp.VarExp VarExp():{	Exp.ExpPrimaria p;}{	p=ExpPrimaria() {return assertvarexp(p);}	}Exp.ExpPrimaria ExpPrimaria(): {		Exp.ExpPrimaria p;}{	p=ExpPrefixa() (LOOKAHEAD(2) p=OpPosFixo(p))* {return p;}}Exp.ExpPrimaria OpPosFixo(Exp.ExpPrimaria lhs):{	Token n;	Exp e;	FuncArgs a;	Exp.ExpPrimaria p;}{	a=FuncArgs() {p=Exp.functionop(lhs, a); return p;}}FuncArgs FuncArgs():{	List<Exp> el=null;	LuaString s;	FuncArgs a;}{	"(" (el=ExpList())? ")"	{ a=FuncArgs.explist(el); return a; }|	s=Str()					{ a=FuncArgs.string(s); return a; }}Exp.ExpPrimaria ExpPrefixa():{	Token n;	Exp e;	Exp.ExpPrimaria p;}{	n=<NAME>		 { p=Exp.nomeprefix(n.image); return p;}	|"(" e=Exp() ")" { p=Exp.parensprefix(e); return p;}}List<Exp> ExpList():{	List<Exp> l = new ArrayList<Exp>();	Exp e;}{	e=Exp() {l.add(e);} ("," e=Exp() {l.add(e);})* {return l;}}Exp Exp():{	Exp e,s;	int op;}{	(e=SimpleExp() | op=Unop() s=Exp() {e=Exp.expunaria(op,s);}) 	(LOOKAHEAD(2) op=Binop() s=Exp() {e=Exp.expbinaria(e,op,s);})* {return e;}}Exp SimpleExp():{	Token n;	LuaString s;	Exp e;}{		<NIL>					{ e=Exp.constante(LuaValue.NIL); return e;} 			|	<TRUE>					{ e=Exp.constante(LuaValue.TRUE); return e;}	|	<FALSE>					{ e=Exp.constante(LuaValue.FALSE); return e;}	|	n=<NUMBER>				{ e=Exp.constantenumerica(n.image); return e; }	|	s=Str()					{ e=Exp.constante(s); return e;}	|	e=ExpPrimaria()			{ return e; } }int Binop():{}	{		"+"   { return Lua.OP_ADD; }	|	"-"   { return Lua.OP_SUB; } 	|	"*"   { return Lua.OP_MUL; } 	|	"/"   { return Lua.OP_DIV; } 	|	"^"   { return Lua.OP_POW; } 	|	"%"   { return Lua.OP_MOD; } 	|	".."  { return Lua.OP_CONCAT; } 	|	"<"   { return Lua.OP_LT;  } 	|	"<="  { return Lua.OP_LE;  } 	|	">"   { return Lua.OP_GT;  } 	|	">="  { return Lua.OP_GE;  }	|	"=="  { return Lua.OP_EQ;  } 	|	"~="  { return Lua.OP_NEQ; } 	|	<AND> { return Lua.OP_AND; } 	|	<OR>  { return Lua.OP_OR;  }}int Unop():{}{		"-"   { return Lua.OP_UNM; }	|	<NOT> { return Lua.OP_NOT; } 	|	"#"   { return Lua.OP_LEN; }}LuaString Str():{}{	<STRING>		{ return Str.quoteString(token.image); } |	<CHARSTRING>	{ return Str.charString(token.image); }}